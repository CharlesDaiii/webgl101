<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>简单音游</title>
    <link rel="stylesheet" href="style.css">

    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@v0.173.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.173.0/examples/jsm/"
          }
        }
    </script>
</head>
<body>
    <!-- Add start page overlay -->
    <div id="start-page" class="overlay">
        <div class="start-content">
            <h1>Rhythm Quest</h1>
            <div id="loading-status">Loading assets... <span id="loading-progress">0</span>%</div>
            <button id="start-button" disabled>Start Game</button>
        </div>
    </div>

    <div id="ui" style="display: none;">
        <div id="score">SCORE: 0</div>
        <div id="combo" style="display: none;">COMBO 0x</div>
        <div id="rules-container">
            <div class="rules-header">▶ How to Play</div>
            <div class="rules-content">
                <ul>
                    <li>Press A, S, D keys to hit notes in left, center, and right lanes</li>
                    <li>Time your hits when notes reach the judgment line</li>
                    <li>Build combos for higher scores</li>
                    <li>Perfect timing = More points!</li>
                    <li>Missing a note breaks your combo</li>
                </ul>
            </div>
        </div>
        <button id="debug-toggle">Debug: OFF</button>
    </div>

    <div id="pause-overlay" class="overlay" style="display: none;">
        <div class="pause-content">
            <h1>PAUSED</h1>
            <p>Press SPACE to resume</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { setupScene, setupLights } from './sceneSetup.js';
        import { EffectManager } from './effectManager.js';
        import { NoteManager } from './noteManager.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { AnimationMixer, LoopOnce } from 'three';
        import { ComboEffect } from './comboEffect.js';

        let score = 0;
        const notes = [];
        const lanes = [-5.0, 0.0, 5.0]; // 三条轨道
        const hitRange = 1.5;      // 判定精度提高
        const noteSpeed = 0.2;     // 音符速度调整
        let debugMode = false;

        let starModel;
        const loader = new GLTFLoader();

        let comboBGM = new Audio('./combo-background.mp3');
        comboBGM.loop = true;  // Make the BGM loop continuously
        comboBGM.volume = 0.3; // Set a reasonable volume

        // Load BGM
        comboBGM.addEventListener('canplaythrough', () => {
            console.log('Combo BGM loaded');
            updateLoadingProgress();
        }, { once: true });

        comboBGM.addEventListener('error', () => {
            console.error('Combo BGM loading failed');
            updateLoadingProgress(); // Still update even on error
        });

        // Add resize handler function
        function handleResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Update camera
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            // Update renderer
            renderer.setSize(width, height);
            composer.setSize(width, height);

            // Update any LineMaterial if you're using Line2
            scene.traverse((object) => {
                if (object.material && object.material.isLineMaterial) {
                    object.material.resolution.set(width, height);
                }
            });
        }

        // 初始化场景
        const { scene, camera, renderer } = setupScene();
        document.body.appendChild(renderer.domElement);
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        // Add resize event listener
        window.addEventListener('resize', handleResize);
        handleResize(); // Call once to set initial size

        const controls = new OrbitControls(camera, renderer.domElement);

        // 下面这些是常用可选参数：
        controls.enableDamping = true;       // 开启惯性缓动
        controls.dampingFactor = 0.05;       // 缓动阻尼系数
        controls.minDistance = 5;           // 相机能拉近到的最小距离
        controls.maxDistance = 100;         // 相机能推远到的最大距离
        controls.target.set(0, 0, 0);       // 焦点（绕着哪个点旋转）
        controls.update();
        // 灯光系统优化
        const lights = setupLights(scene);
        const effectManager = new EffectManager(scene);
        const noteManager = new NoteManager(scene);
        const comboEffects = new ComboEffect(camera, scene);

        // 下坠物体模型
        let starLoaded = false;
        let assetsLoaded = 0;
        const totalAssets = 5; // Total number of assets to load (star, explosion, fire, kirby)
        let gameStarted = false;
        let isPaused = false;

        function updateLoadingProgress() {
            assetsLoaded++;
            const progress = Math.floor((assetsLoaded / totalAssets) * 100);
            document.getElementById('loading-progress').textContent = progress;
            
            if (assetsLoaded === totalAssets) {
                document.getElementById('start-button').disabled = false;
                document.getElementById('loading-status').textContent = 'Ready to play!';
            }
        }

        loader.load('./black_cat_head_plush.glb', 
            (gltf) => {
                starModel = gltf.scene;
                starModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = false;
                        child.material.shadowSide = THREE.FrontSide;
                    }
                });
                // 调整模型原始尺寸
                starModel.scale.set(0.5, 0.5, 0.5);
                starLoaded = true;
                console.log('猫猫头模型加载完成');
                noteManager.initPool(starModel);
                updateLoadingProgress();
            },
            undefined,
            (error) => {
                console.error('模型加载失败:', error);
                updateLoadingProgress(); // Still update even on error
            }
        );

        // 调整相机视角
        camera.position.set(0, 30, 30);
        camera.lookAt(0, 0, 0);
        

        let explosionModel;        // 爆炸场景根节点
        let explosionClips = [];   // 如果爆炸模型内有动画，会保存在这里
        let explosionLoaded = false;
        let fireModel, fireClips = [], fireLoaded = false;
        function checkAllLoaded() {
            if (explosionLoaded && fireLoaded) {
                console.log("Both loaded, now do init...");
                effectManager.initExplosionPool(explosionModel, fireModel);
            }
        }

        loader.load('./smoke.glb', 
            (gltf) => {
                explosionModel = gltf.scene;
                explosionModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = false;
                        child.material.opacity = 0.5;
                        child.material.transparent = true;
                    }
                });
                explosionModel.scale.set(3, 3, 3);
                if (gltf.animations && gltf.animations.length > 0) {
                    effectManager.initExplosionClips(gltf.animations);
                }
                explosionLoaded = true;
                console.log('爆炸特效GLB加载完成');
                checkAllLoaded();
                updateLoadingProgress();
            },
            undefined,
            (error) => {
                console.error('爆炸GLB加载失败:', error);
                updateLoadingProgress();
            }
        );
        loader.load('./fire_animation.glb', (gltf) => {
            fireModel = gltf.scene;
            fireModel.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = false;
                    child.receiveShadow = false;
                }
            });
            fireModel.scale.set(2, 2, 2);
            fireModel.position.y += 5;
            if (gltf.animations && gltf.animations.length > 0) {
                effectManager.initFireClips(gltf.animations);
            }
            fireLoaded = true;
            console.log('火焰GLB加载完成');
            checkAllLoaded();
            updateLoadingProgress();
        }, undefined, (err) => {
            console.error('火焰加载失败:', err);
            updateLoadingProgress();
        });

        // 优化星空背景
        const stars = new THREE.BufferGeometry();
        const starPositions = [];
        for(let i=0; i<2000; i++) {
            starPositions.push(
                Math.random() * 1000 - 500,
                Math.random() * 1000 - 500,
                Math.random() * 1000 - 500
            );
        }
        stars.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ 
            color: 0xFFFFFF, 
            size: 2.5,
            transparent: true,
            opacity: 0.8
        });
        const starField = new THREE.Points(stars, starMaterial);
        scene.add(starField);


        let kirbyModel;
        loader.load('./kirby.glb', 
            (gltf) => {
                kirbyModel = gltf.scene;
                kirbyModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = false;
                        if (child.material) {
                            child.material.shadowSide = THREE.DoubleSide;
                        } 
                    }
                });
                // 调整模型原始尺寸
                kirbyModel.rotation.x -= Math.PI / 2;
                kirbyModel.rotation.y += 0.35;
                console.log('kirby模型加载完成');
                const kirbyInstance = kirbyModel.clone();
                kirbyInstance.scale.set(6, 6, 6);
                kirbyInstance.position.set(0, -8, 0);
                scene.add(kirbyInstance);
                updateLoadingProgress();
            },
            undefined,
            (error) => {
                console.error('模型加载失败:', error);
                updateLoadingProgress();
            }
        );

        const mouthPlaneGeo = new THREE.CircleGeometry(8, 32);
        const mouthPlaneMat = new THREE.MeshStandardMaterial({
            color: 0x8E394F,
            roughness: 0.1,
            metalness: 0.1,
            opacity: 0.3,
            receiveShadow: true
        });
        const mouthPlane = new THREE.Mesh(mouthPlaneGeo, mouthPlaneMat);
        mouthPlane.receiveShadow = true;
        mouthPlane.position.set(0, 0, 0) // 移动到嘴巴里面
        mouthPlane.rotation.set(-Math.PI/2, 0, 0) // 朝向合适方向
        scene.add(mouthPlane); 


        // Debug
        const debugHelpers = {
            axesHelper: new THREE.AxesHelper(50),
            cameraHelper: new THREE.CameraHelper(lights.spotLight.shadow.camera),
            gridHelper: new THREE.GridHelper(100, 100)
        };
        Object.values(debugHelpers).forEach(helper => {
            helper.visible = false;
            scene.add(helper);
        });
        const debugToggle = document.getElementById('debug-toggle');
            debugToggle.addEventListener('click', () => {
            debugMode = !debugMode;
            debugToggle.textContent = `Debug: ${debugMode ? 'ON' : 'OFF'}`;
            Object.values(debugHelpers).forEach(helper => {
                helper.visible = debugMode;
            });
        });

        function createHitEffect(hitPosition) {
            if (!explosionLoaded || !fireLoaded) return;
            if (!(hitPosition instanceof THREE.Vector3)) {
                hitPosition = new THREE.Vector3(hitPosition.x, hitPosition.y, hitPosition.z);
            }
            effectManager.hitEffect(hitPosition);
        }

        // 按键事件绑定多按键
        window.addEventListener('keydown', (e) => {
            const keyMap = { 
                'KeyA': -5, 
                'KeyS': 0, 
                'KeyD': 5 
            };
            if (keyMap[e.code] !== undefined) {
                checkHit(keyMap[e.code]);
            }
        });

        // 优化击中判定
        function checkHit(lane) {
            let hitSuccess = false;
            noteManager.activeNotes.forEach((note, index) => {
                const distance = Math.abs(note.userData.noteMesh.position.y - 0.1);
                const isSameLane = Math.abs(note.userData.noteMesh.position.x - lane) < 0.5;
                
                if (distance < hitRange && isSameLane) {
                    const accuracy = 1 - (distance / hitRange);
                    score += Math.floor(100 + 200 * accuracy);
                    noteManager.combo++;
                    
                    document.getElementById('score').innerHTML = `SCORE: ${score}`;
                    document.getElementById('combo').style.display = 'block';
                    document.getElementById('combo').innerHTML = `COMBO ${noteManager.combo}x`;
                    
                    // Handle combo BGM
                    if (noteManager.combo >= 5 && !comboBGM.playing) {
                        comboBGM.play().catch(e => console.warn("BGM play failed:", e));
                        comboBGM.playing = true;
                    }
                    
                    createHitEffect(note.userData.noteMesh.position);
                    noteManager.recycleNote(note);
                    hitSuccess = true;
                    comboEffects.triggerComboEffect(noteManager.combo);
                }
            });

            if (!hitSuccess) {
                noteManager.combo = 0;
                scene.updateBackground(noteManager.combo);
                document.getElementById('combo').style.display = 'none';
                
                // Stop BGM when combo breaks
                if (comboBGM.playing) {
                    // Fade out the BGM
                    const fadeOut = setInterval(() => {
                        if (comboBGM.volume > 0.02) {
                            comboBGM.volume -= 0.02;
                        } else {
                            comboBGM.pause();
                            comboBGM.volume = 0.3; // Reset volume for next time
                            comboBGM.playing = false;
                            clearInterval(fadeOut);
                        }
                    }, 50);
                }
            }
        }

        let time = 0;
        const activeExplosions = [];
        const clock = new THREE.Clock();
        function animate() {
            if (!gameStarted || isPaused) return;
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            time += 0.016;
            if (Math.random() < 0.01) {
                const laneIndex = Math.floor(Math.random() * lanes.length);
                const lanePosition = lanes[laneIndex];
                
                const tooClose = noteManager.activeNotes.some(note => {
                    const noteLane = note.userData.noteMesh.position.x;
                    const noteY = note.userData.noteMesh.position.y;
                    const distance = Math.abs(noteY - 15);
                    
                    if (noteLane === lanePosition) {
                        if (distance < 5) {
                            return true;
                        }
                    }
                    return false;
                });

                if (!tooClose) {
                    noteManager.spawnNote(laneIndex);
                }
            }
            if (debugMode) {
                debugHelpers.cameraHelper.update();
            }
            effectManager.updateEffects(delta);
            noteManager.updateNotes();
            renderer.shadowMap.autoUpdate = true;
            composer.render();
            controls.update();
        }

        // Add start button functionality
        document.getElementById('start-button').addEventListener('click', () => {
            document.getElementById('start-page').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            gameStarted = true;
            animate(); // Start the animation loop
        });

        document.querySelector('.rules-header').addEventListener('click', function() {
            const content = document.querySelector('.rules-content');
            content.classList.toggle('show');
            this.textContent = content.classList.contains('show') ? '▼ How to Play' : '▶ How to Play';
        });

        // Modify the pause handler
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameStarted) {
                e.preventDefault(); // Prevent page scrolling
                isPaused = !isPaused;
                const pauseOverlay = document.getElementById('pause-overlay');
                pauseOverlay.style.display = isPaused ? 'flex' : 'none';
                
                // Handle BGM during pause
                if (isPaused && comboBGM.playing) {
                    comboBGM.pause();
                } else if (!isPaused) {
                    if (comboBGM.playing) {
                        comboBGM.play().catch(e => console.warn("BGM resume failed:", e));
                    }
                    animate();
                }
            }
        });
    </script>
</body>
</html>